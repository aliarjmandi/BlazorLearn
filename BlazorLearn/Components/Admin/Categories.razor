@page "/admin/categories"
@using BlazorLearn.Common
@using BlazorLearn.Components.Shared
@using BlazorLearn.Data.DTOs
@using BlazorLearn.Services.Implementations
@inject CategoryService CategoryService
@inject IJSRuntime JS
@rendermode InteractiveServer


<h3>مدیریت دسته‌بندی‌ها</h3>

<div class="mb-3 d-flex gap-2">
    <button type="button" class="btn btn-primary btn-sm" @onclick="AddRoot">افزودن دسته ریشه</button>
    <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="ExpandAll">بازکردن همه</button>
    <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="CollapseAll">جمع‌کردن همه</button>
</div>

@if (isLoading)
{
    <p>در حال بارگذاری...</p>
}
else
{
    <div class="tree-container">
        @if (rootEditor is not null)
        {
            <div class="card p-2 my-2">
                <CategoryEditor Dto="rootEditor" OnSave="SaveCreate" OnCancel="@(() => rootEditor = null)" />
            </div>
        }

        @if (tree.Count == 0)
        {
            <p class="text-muted">هیچ دسته‌ای ثبت نشده است.</p>
        }
        else
        {
            <ul class="tree">
                @foreach (var n in tree.OrderBy(x => x.SortOrder))
                {
                    <li>
                        @RenderNode(n)
                    </li>
                }
            </ul>
        }
    </div>
}

@code {



    private List<CategoryTreeNodeDto> tree = new();
    private bool isLoading = true;

    // ویرایشگر افزودن ریشه‌ای
    private CategoryWriteDto? rootEditor;

    // نودهای باز (برای Collapse/Expand)
    private readonly HashSet<Guid> expanded = new();

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
    }

    private async Task ReloadAsync()
    {
        isLoading = true;
        var flat = (await CategoryService.GetAllAsync()).ToList();
        tree = BuildTree(flat, null);

        // پیش‌فرض: فقط ریشه‌ها باز باشند
        expanded.Clear();
        foreach (var r in tree) expanded.Add(r.Id);

        isLoading = false;
        StateHasChanged();
    }

    private static List<CategoryTreeNodeDto> BuildTree(List<CategoryDto> all, Guid? parentId)
    {
        return all.Where(x => x.ParentId == parentId)
                  .OrderBy(x => x.SortOrder)
                  .Select(x => new CategoryTreeNodeDto
                  {
                      Id = x.Id,
                      ParentId = x.ParentId,
                      Name = x.Name,
                      Slug = x.Slug,
                      SortOrder = x.SortOrder,
                      IsActive = x.IsActive,
                      Children = BuildTree(all, x.Id)
                  }).ToList();
    }

    private void AddRoot()
    {
        if (rootEditor is null)
        {
            rootEditor = new CategoryWriteDto
            {
                ParentId = null,
                Name = "",
                Slug = "",
                SortOrder = NextSortOrder(null),
                IsActive = true,
                CreatedAt = DateTime.UtcNow
            };
        }
    }

    private int NextSortOrder(Guid? parentId)
    {
        var siblings = Enumerate(tree, parentId);
        return siblings.Any() ? siblings.Max(x => x.SortOrder) + 1 : 0;
    }

    private static IEnumerable<CategoryTreeNodeDto> Enumerate(List<CategoryTreeNodeDto> all, Guid? parentId)
    {
        if (parentId == null)
            return all;
        var parent = FindNode(all, parentId.Value);
        return parent?.Children ?? Enumerable.Empty<CategoryTreeNodeDto>();
    }

    private static CategoryTreeNodeDto? FindNode(List<CategoryTreeNodeDto> nodes, Guid id)
    {
        foreach (var n in nodes)
        {
            if (n.Id == id) return n;
            var f = FindNode(n.Children, id);
            if (f is not null) return f;
        }
        return null;
    }

    // ---------- رندر هر نود (با باز/بستن) ----------
    private RenderFragment RenderNode(CategoryTreeNodeDto n) => __builder =>
    {
        var hasChildren = n.Children?.Any() == true;
        var isOpen = expanded.Contains(n.Id);

        <div class="node d-flex align-items-center gap-2">
            <button type="button"
                    class="btn btn-link btn-sm p-0 me-1"
                    @onclick="() => ToggleNode(n.Id)"
                    disabled="@(!hasChildren)">
                @if (hasChildren)
                {
                    @:(@(isOpen ? "▼" : "▶"))
                }
                else
                {
                    <span class="text-muted">•</span>
                }
            </button>

            @if (editingNode?.Id == n.Id)
            {
                <CategoryEditor Dto="editingDto!" OnSave="SaveEdit" OnCancel="CancelEdit" />
            }
            else
            {
                <span class="fw-semibold">@n.Name</span>
                <span class="badge text-bg-light">@n.Slug</span>
                <span class="text-muted small">[Sort: @n.SortOrder]</span>
                <span class="form-check form-switch ms-2">
                    <input class="form-check-input" type="checkbox" checked="@n.IsActive" @onchange="(e) => ToggleActive(n, e.Value as bool?)" />
                </span>

                <button type="button" class="btn btn-success btn-sm" @onclick="() => AddChild(n)">زیرشاخه</button>
                <button type="button" class="btn btn-outline-primary btn-sm" @onclick="() => BeginEdit(n)">ویرایش</button>
                <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="() => MoveUp(n)">بالا</button>
                <button type="button" class="btn btn-outline-secondary btn-sm" @onclick="() => MoveDown(n)">پایین</button>
                // <button type="button" class="btn btn-outline-danger btn-sm" @onclick="() => ConfirmAndDelete(n)">حذف</button>
                <button type="button" class="btn btn-outline-danger btn-sm" @onclick="() => AskDelete(n)">حذف</button>

            }
        </div>

        if (pendingChild.TryGetValue(n.Id, out var editor) && editor is not null)
        {
            <div class="card p-2 my-2 ms-3">
                <CategoryEditor Dto="editor" OnSave="SaveCreate" OnCancel="() => { pendingChild.Remove(n.Id); }" />
            </div>
        }

        // بچه‌ها فقط وقتی نود باز است رندر شوند
        if (hasChildren && isOpen)
        {
            <ul>
                @foreach (var c in n.Children.OrderBy(x => x.SortOrder))
                {
                    <li>@RenderNode(c)</li>
                }
            </ul>
        }
    };

    private void ToggleNode(Guid id)
    {
        if (!expanded.Add(id))
            expanded.Remove(id);
    }

    private void ExpandAll()
    {
        expanded.Clear();
        foreach (var id in EnumerateIds(tree))
            expanded.Add(id);
    }

    private void CollapseAll()
    {
        // فقط ریشه‌ها باز بمانند
        expanded.Clear();
        foreach (var r in tree)
            expanded.Add(r.Id);
    }

    private IEnumerable<Guid> EnumerateIds(List<CategoryTreeNodeDto> nodes)
    {
        foreach (var n in nodes)
        {
            yield return n.Id;
            if (n.Children?.Any() == true)
                foreach (var c in EnumerateIds(n.Children))
                    yield return c;
        }
    }

    // --- Add child ---
    private readonly Dictionary<Guid, CategoryWriteDto?> pendingChild = new();

    private void AddChild(CategoryTreeNodeDto parent)
    {
        if (!pendingChild.ContainsKey(parent.Id))
        {
            pendingChild[parent.Id] = new CategoryWriteDto
            {
                ParentId = parent.Id,
                Name = "",
                Slug = "",
                SortOrder = NextSortOrder(parent.Id),
                IsActive = true,
                CreatedAt = DateTime.UtcNow
            };
        }

        // هنگام افزودن زیرشاخه، نود والد را باز نگه‌دار
        expanded.Add(parent.Id);
    }

    // --- Create / Edit ---
    private CategoryDto? editingNode;
    private CategoryWriteDto? editingDto;

    private void BeginEdit(CategoryTreeNodeDto n)
    {
        editingNode = new CategoryDto
        {
            Id = n.Id,
            ParentId = n.ParentId,
            Name = n.Name,
            Slug = n.Slug,
            SortOrder = n.SortOrder,
            IsActive = n.IsActive,
            CreatedAt = DateTime.UtcNow // این مقدار آپدیت نمی‌شود
        };
        editingDto = new CategoryWriteDto
        {
            Id = n.Id,
            ParentId = n.ParentId,
            Name = n.Name,
            Slug = n.Slug,
            SortOrder = n.SortOrder,
            IsActive = n.IsActive,
            CreatedAt = DateTime.UtcNow
        };
    }

    private void CancelEdit()
    {
        editingNode = null;
        editingDto = null;
    }

    private async Task SaveCreate(CategoryWriteDto dto)
    {
        var baseSlug = string.IsNullOrWhiteSpace(dto.Slug) ? SlugUtility.Slugify(dto.Name) : SlugUtility.Slugify(dto.Slug);
        dto.Slug = await CategoryService.EnsureUniqueSlugAsync(baseSlug, ignoreId: null);

        // (اختیاری) fallback
        if (string.IsNullOrWhiteSpace(dto.Slug))
            dto.Slug = Slugify(dto.Name);

        await CategoryService.CreateAsync(dto);
        rootEditor = null;

        if (dto.ParentId is Guid pid && pendingChild.ContainsKey(pid))
            pendingChild.Remove(pid);

        await ReloadAsync();
    }

    private async Task SaveEdit(CategoryWriteDto dto)
    {
        if (dto.Id is null) return;

        var baseSlug = string.IsNullOrWhiteSpace(dto.Slug) ? SlugUtility.Slugify(dto.Name) : SlugUtility.Slugify(dto.Slug);
        dto.Slug = await CategoryService.EnsureUniqueSlugAsync(baseSlug, ignoreId: dto.Id);

        if (string.IsNullOrWhiteSpace(dto.Slug))
            dto.Slug = Slugify(dto.Name);

        await CategoryService.UpdateAsync(dto.Id.Value, dto);
        CancelEdit();
        await ReloadAsync();
    }

    private async Task ConfirmAndDelete(CategoryTreeNodeDto n)
    {
        // اگر فرزند دارد، پیام هشدار قوی‌تر
        var hasChildren = n.Children?.Any() == true;
        var message = hasChildren
            ? "این دسته دارای زیرشاخه است. حذف باعث خطا یا حذف زنجیره‌ای می‌شود. آیا مطمئن هستید؟"
            : "حذف این دسته قطعی است. آیا مطمئن هستید؟";

        var ok = await JS.InvokeAsync<bool>("confirm", message);
        if (!ok) return;

        await CategoryService.DeleteAsync(n.Id);
        await ReloadAsync();
    }

    
    // --- Delete ---
    private async Task DeleteNode(CategoryTreeNodeDto n)
    {
        await CategoryService.DeleteAsync(n.Id);
        await ReloadAsync();
    }



    // --- Toggle Active ---
    private async Task ToggleActive(CategoryTreeNodeDto n, bool? val)
    {
        if (val is null) return;
        var dto = new CategoryWriteDto
        {
            Id = n.Id,
            ParentId = n.ParentId,
            Name = n.Name,
            Slug = n.Slug,
            SortOrder = n.SortOrder,
            IsActive = val.Value,
            CreatedAt = DateTime.UtcNow
        };
        await CategoryService.UpdateAsync(n.Id, dto);
        await ReloadAsync();
    }

    // --- Move up/down (بازچینی SortOrder بین خواهر/برادرها) ---
    private async Task MoveUp(CategoryTreeNodeDto n)
    {
        var siblings = Enumerate(tree, n.ParentId).OrderBy(x => x.SortOrder).ToList();
        var idx = siblings.FindIndex(x => x.Id == n.Id);
        if (idx <= 0) return;

        var prev = siblings[idx - 1];
        await SwapSort(n, prev);
    }

    private async Task MoveDown(CategoryTreeNodeDto n)
    {
        var siblings = Enumerate(tree, n.ParentId).OrderBy(x => x.SortOrder).ToList();
        var idx = siblings.FindIndex(x => x.Id == n.Id);
        if (idx == -1 || idx >= siblings.Count - 1) return;

        var next = siblings[idx + 1];
        await SwapSort(n, next);
    }

    private async Task SwapSort(CategoryTreeNodeDto a, CategoryTreeNodeDto b)
    {
        var aDto = new CategoryWriteDto
        {
            Id = a.Id,
            ParentId = a.ParentId,
            Name = a.Name,
            Slug = a.Slug,
            SortOrder = b.SortOrder,
            IsActive = a.IsActive,
            CreatedAt = DateTime.UtcNow
        };
        var bDto = new CategoryWriteDto
        {
            Id = b.Id,
            ParentId = b.ParentId,
            Name = b.Name,
            Slug = b.Slug,
            SortOrder = a.SortOrder,
            IsActive = b.IsActive,
            CreatedAt = DateTime.UtcNow
        };

        await CategoryService.UpdateAsync(a.Id, aDto);
        await CategoryService.UpdateAsync(b.Id, bDto);
        await ReloadAsync();
    }

    private static string Slugify(string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return "";
        var s = input.Trim();
        s = s.Replace(' ', '-').Replace('/', '-').Replace('\\', '-');
        return s.ToLowerInvariant();
    }

    

    private CategoryTreeNodeDto? toDelete;
    private bool deleteWithChildren = false;
    private string? deleteWarn;

    private async Task AskDelete(CategoryTreeNodeDto n)
    {
        toDelete = n;
        deleteWithChildren = false;
        deleteWarn = null;
        await JS.InvokeVoidAsync("modalHelper.show", "confirmDelete");
    }

    private async Task ConfirmDelete()
    {
        if (toDelete is null) return;

        var hasChildren = toDelete.Children?.Any() == true;

        // اگر فرزند دارد و تیک حذف زنجیره‌ای نزده‌اند، پیام بده و مودال را باز نگه‌دار
        if (hasChildren && !deleteWithChildren)
        {
            deleteWarn = "این دسته دارای زیرشاخه است. برای حذف، گزینهٔ «حذف به‌همراه زیرشاخه‌ها» را فعال کنید.";
            StateHasChanged();
            return;
        }

        if (hasChildren && deleteWithChildren)
            await CategoryService.DeleteTreeAsync(toDelete.Id);   // 👈 متد جدید
        else
            await CategoryService.DeleteAsync(toDelete.Id);

        toDelete = null;
        deleteWithChildren = false;
        deleteWarn = null;

        await JS.InvokeVoidAsync("modalHelper.hide", "confirmDelete");
        await ReloadAsync();
    }

}
<ConfirmModal ModalId="confirmDelete"
              Title="تأیید حذف"
              ConfirmText="حذف"
              CancelText="انصراف"
              OnConfirm="ConfirmDelete">
    <Message>
        @if (toDelete is not null)
        {
            <p>آیا از حذف «<strong>@toDelete.Name</strong>» مطمئن هستید؟</p>

            @if (toDelete.Children?.Any() == true)
            {
                <div class="alert alert-warning py-2">
                    این دسته دارای زیرشاخه است.
                </div>
                <div class="form-check mb-0">
                    <input id="chkDelChildren" class="form-check-input"
                           type="checkbox" @bind="deleteWithChildren" />
                    <label class="form-check-label" for="chkDelChildren">
                        حذف به‌همراه تمام زیرشاخه‌ها
                    </label>
                </div>
                @if (!string.IsNullOrEmpty(deleteWarn))
                {
                    <div class="text-danger small mt-2">@deleteWarn</div>
                }
            }
        }
    </Message>
</ConfirmModal>

