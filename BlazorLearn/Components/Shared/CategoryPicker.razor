@using BlazorLearn.Data.DTOs
@using BlazorLearn.Services.Implementations
@inject CategoryService CategoryService

<div class="category-picker">
    <div class="cp-toolbar">
        <input class="form-control form-control-sm cp-search"
               placeholder="جستجو در دسته‌ها…"
               @bind="search"
               @bind:event="oninput" />
        <div class="btn-group btn-group-sm">
            <button class="btn btn-outline-secondary" @onclick="ExpandAll">بازکردن همه</button>
            <button class="btn btn-outline-secondary" @onclick="CollapseAll">جمع‌کردن همه</button>
            <button class="btn btn-outline-secondary" @onclick="ClearSearch" title="پاک‌کردن جستجو">پاک</button>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="text-muted small">در حال بارگذاری…</div>
    }
    else
    {
        var view = string.IsNullOrWhiteSpace(search)
        ? tree
        : FilterTree(tree, search);

        <div class="cp-tree">
            @if (view.Count == 0)
            {
                <div class="text-muted small">چیزی پیدا نشد.</div>
            }
            else
            {
                <ul class="cp-ul">
                    @foreach (var n in view.OrderBy(x => x.SortOrder))
                    {
                        <li>@RenderNode(n)</li>
                    }
                </ul>
            }
        </div>
    }
</div>

@code {
    [Parameter] public Guid? SelectedId { get; set; }
    [Parameter] public EventCallback<Guid?> SelectedIdChanged { get; set; }
    [Parameter] public EventCallback<CategoryTreeNodeDto> OnPicked { get; set; }
    [Parameter] public string Height { get; set; } = "55vh"; // ارتفاع اسکرول
    

    private List<CategoryTreeNodeDto> tree = new();
    private bool isLoading = true;
    private string search = string.Empty;
    private HashSet<Guid> expanded = new();

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        // وقتی SelectedId تغییر کرد، نود انتخابی و اجدادش رو Expand کن
        if (SelectedId.HasValue && SelectedId.Value != Guid.Empty)
        {
            // ExpandPathTo(SelectedId.Value);  // این متد خودت بنویس: از درخت مسیر تا ریشه را پیدا و به expanded اضافه کن
            // selectedNodeId = SelectedId.Value;
            StateHasChanged();
        }
    }

    private async Task ReloadAsync()
    {
        isLoading = true;
        var flat = (await CategoryService.GetAllAsync()).Where(c => c.IsActive).ToList();
        tree = BuildTree(flat, null);

        // ریشه‌ها به‌صورت پیش‌فرض باز
        foreach (var r in tree) expanded.Add(r.Id);

        isLoading = false;
        StateHasChanged();
    }

    private static List<CategoryTreeNodeDto> BuildTree(List<CategoryDto> all, Guid? parentId)
    {
        return all.Where(x => x.ParentId == parentId)
                  .OrderBy(x => x.SortOrder)
                  .Select(x => new CategoryTreeNodeDto
                  {
                      Id = x.Id,
                      ParentId = x.ParentId,
                      Name = x.Name,
                      Slug = x.Slug,
                      SortOrder = x.SortOrder,
                      IsActive = x.IsActive,
                      Children = BuildTree(all, x.Id)
                  }).ToList();
    }

    // --- رندر نود ---
    private RenderFragment RenderNode(CategoryTreeNodeDto n) => builder =>
    {
        var seq = 0;
        var hasChildren = n.Children?.Any() == true;
        var isOpen = expanded.Contains(n.Id);

        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", "cp-node");

        // caret
        builder.OpenElement(seq++, "span");
        builder.AddAttribute(seq++, "class", $"cp-caret {(hasChildren ? "" : "cp-caret-disabled")}");
        if (hasChildren)
            builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => Toggle(n.Id)));
        builder.AddContent(seq++, hasChildren ? (isOpen ? "▼" : "▶") : "•");
        builder.CloseElement();

        // نام
        builder.OpenElement(seq++, "button");
        var cls = "cp-name btn btn-link btn-sm";
        if (SelectedId == n.Id) cls += " cp-selected";
        builder.AddAttribute(seq++, "class", cls);
        builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => Pick(n)));
        builder.AddContent(seq++, Highlight(n.Name, search));
        builder.CloseElement();

        builder.CloseElement(); // .cp-node

        // children
        if (hasChildren && isOpen)
        {
            builder.OpenElement(seq++, "ul");
            builder.AddAttribute(seq++, "class", "cp-ul");
            foreach (var c in n.Children.OrderBy(x => x.SortOrder))
            {
                builder.OpenElement(seq++, "li");
                builder.AddContent(seq++, RenderNode(c));
                builder.CloseElement();
            }
            builder.CloseElement();
        }
    };

    private void Toggle(Guid id)
    {
        if (expanded.Contains(id)) expanded.Remove(id); else expanded.Add(id);
    }

    private void ExpandAll()
    {
        void Walk(List<CategoryTreeNodeDto> nodes)
        {
            foreach (var n in nodes) { expanded.Add(n.Id); Walk(n.Children); }
        }
        Walk(tree);
    }

    private void CollapseAll()
    {
        expanded.Clear();
        foreach (var r in tree) expanded.Add(r.Id); // ریشه باز بماند
    }

    private void ClearSearch() => search = string.Empty;

    // --- فیلتر درخت بر اساس جستجو ---
    private static List<CategoryTreeNodeDto> FilterTree(List<CategoryTreeNodeDto> src, string q)
    {
        q = q.Trim();
        if (string.IsNullOrEmpty(q)) return src;

        bool Match(CategoryTreeNodeDto n)
            => (n.Name?.Contains(q, StringComparison.CurrentCultureIgnoreCase) ?? false)
               || (n.Slug?.Contains(q, StringComparison.OrdinalIgnoreCase) ?? false);

        CategoryTreeNodeDto? FilterNode(CategoryTreeNodeDto n)
        {
            var children = new List<CategoryTreeNodeDto>();
            foreach (var c in n.Children)
            {
                var fc = FilterNode(c);
                if (fc != null) children.Add(fc);
            }

            if (Match(n) || children.Count > 0)
            {
                return new CategoryTreeNodeDto
                {
                    Id = n.Id,
                    ParentId = n.ParentId,
                    Name = n.Name,
                    Slug = n.Slug,
                    SortOrder = n.SortOrder,
                    IsActive = n.IsActive,
                    Children = children
                };
            }
            return null;
        }

        var res = new List<CategoryTreeNodeDto>();
        foreach (var r in src)
        {
            var fr = FilterNode(r);
            if (fr != null) res.Add(fr);
        }
        return res;
    }

    // هایلایت متن جستجو
    private MarkupString Highlight(string text, string term)
    {
        if (string.IsNullOrWhiteSpace(term) || string.IsNullOrWhiteSpace(text))
            return (MarkupString)text;

        var idx = text.IndexOf(term, StringComparison.CurrentCultureIgnoreCase);
        if (idx < 0) return (MarkupString)text;

        var before = text.Substring(0, idx);
        var match = text.Substring(idx, term.Length);
        var after = text[(idx + term.Length)..];
        var html = $"{before}<mark>{match}</mark>{after}";
        return (MarkupString)html;
    }

    private async Task Pick(CategoryTreeNodeDto n)
    {
        SelectedId = n.Id;
        await SelectedIdChanged.InvokeAsync(n.Id);
        if (OnPicked.HasDelegate) await OnPicked.InvokeAsync(n);
    }
}
