@using BlazorLearn.Data.DTOs
@inject BlazorLearn.Services.Implementations.CategoryService CategoryService
@inject IJSRuntime JS
@rendermode InteractiveServer

<!-- نوار ابزار (جستجو) -->
<div class="category-picker">
    <div class="cp-toolbar">
        <input class="form-control cp-search"
               placeholder="جستجو در دسته‌ها..."
               @bind="search" @bind:event="oninput" />
    </div>

    @if (isLoading)
    {
        <div class="text-muted small">در حال بارگذاری...</div>
    }
    else
    {
        <!-- کانتینر اسکرول‌دار درخت -->
        <div class="cp-tree">
            <ul class="cp-ul">
                @foreach (var n in filteredRoots)
                {
                    @RenderNode(n)
                }
            </ul>
        </div>
    }
</div>

@code {
    // ======= پارامترها/ایونت‌ها =======

    /// <summary>
    /// آیدی نودی که بیرون کامپوننت انتخاب شده (برای هایلایت/اسکرول روی آن)
    /// </summary>
    [Parameter] public Guid? SelectedId { get; set; }

    /// <summary>
    /// وقتی کاربر روی یک نود کلیک کند، به والد اعلام می‌کنیم
    /// </summary>
    [Parameter] public EventCallback<CategoryTreeNodeDto> OnPicked { get; set; }

    // ======= وضعیت داخلی =======

    private List<CategoryTreeNodeDto> tree = new();       // کل درخت
    private bool isLoading = true;                        // بارگذاری اولیه
    private Guid? selectedNodeId;                         // نود انتخابی فعلی
    private HashSet<Guid> expanded = new();               // مجموعه‌ی نودهای بازشده
    private Dictionary<Guid, Guid?> parentOf = new();     // نقشه‌ی والد برای هر نود
    private string? search;                               // رشته جستجو
    private bool _pendingScroll;                          // اسکرول پس از رندر

    /// <summary>
    /// آی‌دی المنتی که باید به آن اسکرول شود (روی نود انتخابی)
    /// </summary>
    private string SelectedElementId => selectedNodeId.HasValue ? "categoryPicker_selected" : "";

    /// <summary>
    /// ریشه‌های قابل‌نمایش با توجه به فیلتر (search)
    /// </summary>
    private IEnumerable<CategoryTreeNodeDto> filteredRoots
        => tree.Where(n => MatchesOrDescends(search, n))
               .OrderBy(n => n.SortOrder);

    // ======= چرخه‌ی عمر =======

    /// <summary>
    /// بارگذاری اولیه‌ی دسته‌بندی‌ها و ساخت درخت و parentMap
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
    }

    /// <summary>
    /// اگر SelectedId از بیرون عوض شد، مسیر اجداد را باز کن و برای اسکرول علامت بگذار
    /// </summary>
    protected override async Task OnParametersSetAsync()
    {
        if (SelectedId.HasValue && SelectedId.Value != Guid.Empty)
        {
            selectedNodeId = SelectedId;
            ExpandPathTo(SelectedId.Value);
            _pendingScroll = true;
        }
        await base.OnParametersSetAsync();
    }

    /// <summary>
    /// پس از رندر، اگر لازم بود روی نود انتخابی اسکرول کن
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await Task.Delay(50); // اطمینان از آماده بودن DOM و اسکریپت

        if (_pendingScroll && !string.IsNullOrWhiteSpace(SelectedElementId))
        {
            _pendingScroll = false;
            try { await JS.InvokeVoidAsync("modalHelper.scrollIntoView", SelectedElementId); }
            catch (JSException) { /* اگر اسکریپت/DOM حاضر نبود؛ مشکلی نیست */ }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    // ======= دیتا/درخت =======

    /// <summary>
    /// واکشی همه‌ی دسته‌ها، ساخت درخت و parentMap
    /// </summary>
    private async Task ReloadAsync()
    {
        isLoading = true;

        var flat = (await CategoryService.GetAllAsync()).ToList();
        tree = BuildTree(flat, null);

        parentOf.Clear();
        BuildParentMap(tree, null);

        isLoading = false;
        StateHasChanged();
    }

    /// <summary>
    /// تبدیل لیست مسطح به درخت با استفاده از ParentId
    /// </summary>
    private static List<CategoryTreeNodeDto> BuildTree(List<CategoryDto> all, Guid? parentId)
        => all.Where(x => x.ParentId == parentId)
              .OrderBy(x => x.SortOrder)
              .Select(x => new CategoryTreeNodeDto
              {
                  Id = x.Id,
                  ParentId = x.ParentId,
                  Name = x.Name,
                  Slug = x.Slug,
                  SortOrder = x.SortOrder,
                  IsActive = x.IsActive,
                  Children = BuildTree(all, x.Id)
              }).ToList();

    /// <summary>
    /// ساخت دیکشنری والد برای هر نود (برای expand مسیر اجداد)
    /// </summary>
    private void BuildParentMap(IEnumerable<CategoryTreeNodeDto> nodes, Guid? parentId)
    {
        foreach (var n in nodes)
        {
            parentOf[n.Id] = parentId;
            if (n.Children?.Count > 0)
                BuildParentMap(n.Children, n.Id);
        }
    }

    /// <summary>
    /// باز کردن همه‌ی اجداد یک نود تا ریشه
    /// </summary>
    private void ExpandPathTo(Guid id)
    {
        var cur = id;
        while (parentOf.TryGetValue(cur, out var p) && p.HasValue)
        {
            expanded.Add(p.Value);
            cur = p.Value;
        }
    }

    // ======= فیلتر/جستجو =======

    /// <summary>
    /// تشخیص انطباق نود با متن جستجو (نام یا اسلاگ)
    /// </summary>
    private static bool Matches(string? text, CategoryTreeNodeDto n)
        => string.IsNullOrWhiteSpace(text)
           || (n.Name?.Contains(text, StringComparison.CurrentCultureIgnoreCase) ?? false)
           || (n.Slug?.Contains(text, StringComparison.OrdinalIgnoreCase) ?? false);

    /// <summary>
    /// نود یا هر کدام از نوادگانش با جستجو منطبق است؟
    /// </summary>
    private bool MatchesOrDescends(string? text, CategoryTreeNodeDto n)
        => Matches(text, n) || (n.Children?.Any(c => MatchesOrDescends(text, c)) ?? false);

    // ======= رندر درخت =======

    /// <summary>
    /// رندر یک نود درخت به‌صورت بازگشتی (caret، نام، و فرزندان در صورت expand)
    /// </summary>
    private RenderFragment RenderNode(CategoryTreeNodeDto n) => __builder =>
    {
        if (!MatchesOrDescends(search, n)) return;

        var seq = 0;
        bool hasChildren = n.Children?.Any() == true;
        bool isExpanded = expanded.Contains(n.Id);
        bool isSelected = selectedNodeId == n.Id;

        __builder.OpenElement(seq++, "li");
        __builder.AddAttribute(seq++, "class", "cp-li");
        if (isSelected)
            __builder.AddAttribute(seq++, "id", "categoryPicker_selected");

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "cp-node");

        // caret
        if (hasChildren)
        {
            __builder.OpenElement(seq++, "a");
            __builder.AddAttribute(seq++, "role", "button");
            __builder.AddAttribute(seq++, "class", "cp-caret");
            __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => Toggle(n.Id)));
            __builder.AddContent(seq++, isExpanded ? "▼" : "◄");
            __builder.CloseElement();
        }
        else
        {
            __builder.OpenElement(seq++, "span");
            __builder.AddAttribute(seq++, "class", "cp-caret cp-caret-disabled");
            __builder.AddContent(seq++, "•");
            __builder.CloseElement();
        }

        // نام نود – بدون اتکای CSS؛ اگر انتخابی است، نشان متنی اضافه می‌کنیم
        __builder.OpenElement(seq++, "button");
        __builder.AddAttribute(seq++, "type", "button");
        __builder.AddAttribute(seq++, "class", "btn btn-link btn-sm text-start px-2 cp-name");
        __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => Pick(n)));
        __builder.AddContent(seq++, n.Name);
        if (isSelected)
        {
            // نشان انتخابی
            __builder.AddContent(seq++, " (✔)");
            // اگر علامت دیگری می‌خواهی یکی از این‌ها را جایگزین کن:
            // __builder.AddContent(seq++, " ⟪⟫");
            // __builder.AddContent(seq++, " (انتخاب‌شده)");
        }
        __builder.CloseElement(); // button

        __builder.CloseElement(); // div.cp-node

        if (hasChildren && isExpanded)
        {
            __builder.OpenElement(seq++, "ul");
            __builder.AddAttribute(seq++, "class", "cp-ul");
            foreach (var c in n.Children!.OrderBy(x => x.SortOrder))
                __builder.AddContent(seq++, RenderNode(c));
            __builder.CloseElement();
        }

        __builder.CloseElement(); // li
    };

    // ======= تعامل کاربر =======

    /// <summary>
    /// باز/بسته کردن یک شاخه
    /// </summary>
    private void Toggle(Guid id)
    {
        if (!expanded.Remove(id))
            expanded.Add(id);

        StateHasChanged();
    }

    /// <summary>
    /// انتخاب یک نود: باز کردن مسیر اجداد، اسکرول، و فایر کردن OnPicked
    /// </summary>
    private async Task Pick(CategoryTreeNodeDto n)
    {
        selectedNodeId = n.Id;
        ExpandPathTo(n.Id);      // اجداد باز بمانند
        _pendingScroll = true;   // بعد از رندر اسکرول کن

        if (OnPicked.HasDelegate)
            await OnPicked.InvokeAsync(n);

        StateHasChanged();
    }
}
